#!/bin/bash
# Script: generate-env-from-terraform.sh
# Description: Generate .env file from Terraform outputs for Kustomize replacements
# Usage: ./generate-env-from-terraform.sh <environment>

set -euo pipefail

ENVIRONMENT="${1:-production}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TERRAFORM_DIR="${SCRIPT_DIR}/../../terraform"
OUTPUT_ENV_FILE="${SCRIPT_DIR}/../overlays/${ENVIRONMENT}/.env"

echo "ðŸ”§ Generating .env file for environment: ${ENVIRONMENT}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Step 1: Validate Terraform directory
if [[ ! -d "$TERRAFORM_DIR" ]]; then
  echo "âŒ ERROR: Terraform directory not found: $TERRAFORM_DIR"
  exit 1
fi

cd "$TERRAFORM_DIR"

# Step 2: Check Terraform state
if ! terraform show >/dev/null 2>&1; then
  echo "âŒ ERROR: Terraform state not initialized or valid"
  echo "   Please run 'terraform init' and 'terraform apply' first"
  exit 1
fi

echo "âœ… Terraform state found"

# Step 3: Get AWS Account ID
AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo "")
if [[ -z "$AWS_ACCOUNT_ID" ]]; then
  echo "âŒ ERROR: Could not retrieve AWS account ID"
  echo "   Please configure AWS CLI credentials"
  exit 1
fi
echo "ðŸ” AWS Account ID: $AWS_ACCOUNT_ID"

# Step 4: Get AWS Region
AWS_REGION=$(terraform output -raw aws_region 2>/dev/null || echo "us-east-1")
echo "ðŸŒ AWS Region: $AWS_REGION"

# Step 5: Get Namespace
case "$ENVIRONMENT" in
  dev|development)
    NAMESPACE="ghost-protocol-dev"
    ;;
  staging)
    NAMESPACE="ghost-protocol-staging"
    ;;
  prod|production)
    NAMESPACE="ghost-protocol-prod"
    ;;
  *)
    echo "âŒ ERROR: Unknown environment: $ENVIRONMENT"
    echo "   Supported: dev, staging, production"
    exit 1
    ;;
esac
echo "ðŸ“¦ Namespace: $NAMESPACE"

# Step 6: Get IRSA Role ARNs (with fallback for Stage 1 deployment)
echo ""
echo "ðŸ“¥ Retrieving IRSA Role ARNs..."

API_GATEWAY_ROLE_ARN=$(terraform output -raw api_gateway_irsa_role_arn 2>/dev/null || echo "")
INDEXER_ROLE_ARN=$(terraform output -raw indexer_irsa_role_arn 2>/dev/null || echo "")
RPC_ORCHESTRATOR_ROLE_ARN=$(terraform output -raw rpc_orchestrator_irsa_role_arn 2>/dev/null || echo "")
AI_ENGINE_ROLE_ARN=$(terraform output -raw ai_engine_irsa_role_arn 2>/dev/null || echo "")
LOKI_ROLE_ARN=$(terraform output -raw loki_irsa_role_arn 2>/dev/null || echo "")

# If IRSA roles don't exist yet (Stage 1), use placeholders
if [[ -z "$API_GATEWAY_ROLE_ARN" ]] || [[ "$API_GATEWAY_ROLE_ARN" == "null" ]]; then
  echo "âš ï¸  WARNING: IRSA roles not found in Terraform outputs"
  echo "   This is expected if you're in Stage 1 of deployment"
  echo "   Using placeholder values - you'll need to re-run after Stage 2"
  
  API_GATEWAY_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/ghost-protocol-${ENVIRONMENT}-api-gateway-pod-role"
  INDEXER_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/ghost-protocol-${ENVIRONMENT}-indexer-pod-role"
  RPC_ORCHESTRATOR_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/ghost-protocol-${ENVIRONMENT}-rpc-orchestrator-pod-role"
  AI_ENGINE_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/ghost-protocol-${ENVIRONMENT}-ai-engine-pod-role"
  LOKI_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/ghost-protocol-${ENVIRONMENT}-loki-pod-role"
else
  echo "âœ… IRSA roles retrieved successfully"
fi

# Step 7: Get ECR Repository URL
ECR_REPOSITORY_URL="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ghost-protocol"
echo "ðŸ³ ECR Repository: $ECR_REPOSITORY_URL"

# Step 8: Get Cluster Name
CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "ghost-protocol-${ENVIRONMENT}")
echo "â˜¸ï¸  EKS Cluster: $CLUSTER_NAME"

# Step 9: Create .env file
echo ""
echo "ðŸ“ Generating .env file..."
mkdir -p "$(dirname "$OUTPUT_ENV_FILE")"

cat > "$OUTPUT_ENV_FILE" <<EOF
# Auto-generated by generate-env-from-terraform.sh
# Environment: ${ENVIRONMENT}
# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
# DO NOT EDIT MANUALLY - This file is auto-generated

# AWS Configuration
AWS_ACCOUNT_ID=${AWS_ACCOUNT_ID}
AWS_REGION=${AWS_REGION}
ECR_REPOSITORY_URL=${ECR_REPOSITORY_URL}

# Kubernetes Configuration
NAMESPACE=${NAMESPACE}
CLUSTER_NAME=${CLUSTER_NAME}

# IRSA Role ARNs
API_GATEWAY_ROLE_ARN=${API_GATEWAY_ROLE_ARN}
INDEXER_ROLE_ARN=${INDEXER_ROLE_ARN}
RPC_ORCHESTRATOR_ROLE_ARN=${RPC_ORCHESTRATOR_ROLE_ARN}
AI_ENGINE_ROLE_ARN=${AI_ENGINE_ROLE_ARN}
LOKI_ROLE_ARN=${LOKI_ROLE_ARN}

# DNS Configuration (for namespace-agnostic service discovery)
MONITORING_NAMESPACE=${NAMESPACE}
EOF

# Step 10: Validate .env file
if [[ ! -f "$OUTPUT_ENV_FILE" ]]; then
  echo "âŒ ERROR: Failed to create .env file"
  exit 1
fi

echo "âœ… .env file created: $OUTPUT_ENV_FILE"
echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ðŸ“‹ Generated Values:"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
cat "$OUTPUT_ENV_FILE"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "âœ… SUCCESS: .env file ready for Kustomize"
echo ""
echo "Next steps:"
echo "  1. Review the generated values above"
echo "  2. Run: kubectl apply -k infra/k8s/overlays/${ENVIRONMENT}"
echo "  3. Verify: kubectl get sa -n ${NAMESPACE} -o yaml | grep role-arn"
